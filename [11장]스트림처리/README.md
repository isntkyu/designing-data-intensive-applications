## 스트림 처리

일괄처리는 출력이 파생데이터 형태이고, 다시 수행해서 재생성 가능한 데이터셋이다.  
하지만, 입력크기를 유한한 크기로 한정한다는 가정이 있다.  
입력이 한정되지 않는다면, 일정 청크로 입력을 나눠야할 것이고, 그 기준을 이벤트 단위로 잡는 것이 스트림 처리의 개념이다.

### 이벤트 스트림 전송

이벤트는 일반적으로 발생 타임스탬프를 포함한다.  
파일 시스템에서는 관련 레코드 집합을 파일 이름으로 식별하지만 스트림 시스템에서는 대개 **토픽**이나 스트림으로 이벤트를 묶는다.

#### 메시징 시스템

소비자가 메시지를 처리하는 속도보다 빠르게 메시지를 생산한다면,  
유닉스파이프와 TCP는 배압(메시지를 못보내게 막음)을 사용한다.  
메시지가 큐에 버퍼링될 때 어떤 현상이 생길지 이해하는게 중요하다.  
(시스템이 중단되는가, 성능이 저하되는가)

#### 생산자에서 소비자로 메시지를 직접 전달하기

많은 메시지 시스템은 노드를 통하지 않고 네트워크로 직접 통신한다.  
직접 메시징 시스템에서는 메시지 유실을 대비한 애플리케이션 코드를 짜야한다.

#### 메시지 브로커

- 메시지큐 라고도 한다. 메시지 스트림을 처리하는 데 최적화된 데이터베이스며 서버로 구동된다.
- 클라이언트의 상태변경에 쉽게 대처할 수 있다.
- 어떤 메시지 브로커는 메모리에 보관하지만, 다른 브로커는 백업용 디스크에 보관한다.
- 배압을 사용하지 않고 큐를 늘리는 설정도 있을 수 있다.
- 소비자가 비동기로 동작한다. (생산자가 메시지 처리여부를 확인하지 않음)

#### 메시지 브로커와 데이터베이스의 비교

- 브로커는 컨슈머에게 배달이 성공하면 메시지를 삭제한다.
- 큐(작업 집합) 크기가 작다. 소비자가 느리면 메모리가 넘쳐서 디스크에 저장할 수도 있어서 처리량이 저하된다.
- 데이터베이스는 스냅숏을 기준으로 질의한다. 브로커는 질의는 불가하지만 변경(새 이벤트) 즉각 클라이언트에게 알려준다.

#### 복수 소비자

- 로드밸런싱: 메시지 병렬처리를 위해 여러 소비자에게 메시지를 전달한다.
- 팬 아웃: 하나의 메시지를 여러 소비자에게 전달한다.
- 두 패턴은 함께 사용가능하다.

#### 확인 응답과 재전송

소비자에게 장애가 발생할 경우 브로커는 메시지를 다른 소비자로 재전송한다.  
이 경우에 메시지의 순서가 보장되지 않을 수 있다. 메시지간의 인과성이 있다면 크리티컬한 문제다.

#### 파티셔닝된 로그

지금까지는 AMQP/JMS 형식의 메시징처리에 대한 설명으로 메시지가 영구보관되지 않는 형태다.  
데이터베이스의 지속성있는 저장과 메시징 시스템의 지연 시간이 짧은 알림 기능을 조합할 수 없을까?  
그게 바로 **로그 기반 메시지 브로커**의 기본 아이디어이다.

#### 로그를 사용한 메시지 저장소

로그를 파티셔닝하면 각 파티션끼리 독립적으로 읽고 쓰기가 가능한 분리된 로그가 된다.  
토픽은 같은 형식의 메시지를 전달하는 파티션들의 그룹으로 정의한다.  
브로커는 각 파티션내에서 모든 메시지에 오프셋이라는 순번을 부여한다.  
즉 다른 파티션간 메시지의 순서는 보장하지 않는다.  
예시로는 카프카, 키네시스, 트위터의분산로그가 있다. 구글의 pub/sub은 JMS형식이다.

#### 로그 방식과 전통적인 메시징 방식의 비교

로그 기반 접근법은 당연히 팬 아웃 메시징 방식을 제공한다.  
각 클라이언트는 할당된 파티션의 메시지를 모두 소비하기 때문에 지연되는 경우도 있다(선두차단)  
메시지를 처리하는 비용이 비싸고 메시지 단위로 병렬화 처리하고 싶지만 메시지 순서는 중요하지 않다면 JMS/AMQP이 적합하지만  
반면 처리량이 많고 메시지를 처리하는 속도가 빠르지만 메시지 순서가 중요하다면 로그 기반 접근법이 효과적이다.

#### 소비자 오프셋

- 브로커는 데이터베이스의 리더처럼 동작하고, 소비자는 팔로워처럼 동작한다.
- 연결이 해제되었다 복구되어도 기록된 오프셋부터 처리가 재개된다.
- 소비자에 장애가 발생하면 다른 소비자 노드에 파티션을 할당한다.
- 장애소비자가 메시지를 처리했지만 오프셋을 기록 못한 경우라면 메시지는 두 번 처리된다.

#### 소비자가 생산자를 따라갈 수 없을 때

선택지는 메세지 버리기, 버퍼링, 배압적용하기 이다.  
로그기반 접근법을 이 방식으로 분류하자면 버퍼링형태다.

---

### 데이터베이스와 스트림

#### 변경 데이터 캡처(CDC)

데이터변경을 감지(binlog등). 로그 컴팩션등의 기법으로 파생 데이터 시스템을 생성하는 기법

카프카 커넥트

#### 이벤트 소싱

애플리케이션 레벨에서 이벤트로그를 기록. CDC와는 다른 개념  
이벤트와 명령을 구분해야한다. 이벤트는 생성시점에 사실이 되고, 이벤트 스트림 소비자는 이벤트를 거절하지 못한다.

입력파일(데이터베이스)의 불변성은 변경로그로부터 보존된다.

---

### 스트림 처리

스트림을 처리하며 파생스트림을 생성하는 스트림 처리 코드 조각을 작업(job) 또는 연산자(operator)라고 한다.

스트림은 오랜 기간 모니터링 목적으로 사용돼 왔다.

#### 복잡한 이벤트 처리(CEP)

특정 이벤트 패턴을 검색해야하는 애플리케이션에 적합하다.  
Esper, 인포스피어 스트림, 팁코 스트림베이스, SQL스트림, 쌈자 등이 있다.

#### 스트림 분석

특정 패턴을 찾는것보다 대량의 이벤트를 집계하고 지표를 뽑는다.  
아파치스톰, 스파크 스트리밍, 플링크, 콩코드, 쌈자, 카프카스트림 등이 분석용도로 설계됐다. 호스팅 서비스로는 데이터플로우 애저스트림분석이 있다.

#### 구체화 뷰 유지하기

구체화 뷰를 만들려면 잠재적으로 임의의 시간 범위에 발생한 모든 이벤트가 필요하다. (window: 집계 시간 간격)  
그 결과 시작 시점까지 늘려진 윈도우가 필요하다.

#### 메시지 전달과 RPC

액터 프레임워크, 아파치 스톰의 분산RPC
