## 트랜잭션

**앞부분 요약**

일반적으로 개발자가 애플리케이션에서 원하는 용도로 사용하는 트랜잭션은 다중 객체 트랜잭션이고
단일 객체 트랜잭션도 있으나 경량화된 트랜잭션임.

ACID - 설명

---

### 완화된 격리수준

실제로 데이터베이스들은
완화된 격리수준을 사용한다.
모든 동시성이슈로부터 보호해주지는 않는다.

성능 등의 이슈로 완전한 직렬성 격리가 아니기 때문에 발생할 수 있는 동시성문제의 종류를 잘 이해하고 방지해보자.

- 커밋 후 읽기

더티읽기와 더티쓰기가 없다.

- 더티 읽기 방지

  데이터가 쓰였지만 커밋이 되기 전에 다른 트랜잭션에서 데이터를 읽는 현상.

- 더티 쓰기 방지

  커밋되지 않은 트랜잭션들끼리 동시에 갱신하려고 해서 데이터를 덮어쓴다.

커밋 후 읽기는 널리 쓰이는 격리수준이다 (oracle, postgresql, memsql ,,)
흔한 방법으로는 row 수준 잠금을 이용한다.
트랜잭션이 잠금을 획득하고 커밋/어보트 전까지 잠금을 보유한다.

읽기 요청이 같은 잠금을 사용하도록하면 해결할 수 있지만, 모든 읽기의 응답지연이 있다
혹은 트랜잭션이 커밋되기전까지는 과거의 값을 읽게된다.

그럼에도 불구하고 발생할 수 있는 문제: 비반복 읽기(읽기 스큐)
ex)

> A가 1계좌를 읽음 > B트랜잭션이 1계좌와 2계좌 수정 > A가 2계좌 읽음

새로고침만 하면 해결되는 문제지만 일시적으로 A는 알고있는 1+2 계좌의 총액을 틀리게 읽게 됨.

해결법이 **스냅숏 격리**  
커밋이 완료된 상태인 데이터베이스의 일관된 스냅숏을 읽는다.
살짝 과거일 순 있지민 특정 시점의 고정된 데이터를 읽을 수 있다.
널리 쓰이는 방법이다(mysql, oracle, postgresql, innoDB, sql server ...)
읽을 떈 잠금이 필요없기도 하다.

스냅숏 격리를 구현하기 위해서는
데이터베이스는 각 객체의 여러 버전을 갖고 있어야한다 (MVCC)

\*MVCC: 다중 버전 동시성 제어, postgreSQL에서는 transactionId를 사용해서 실제로 버전별로 row를 여러개로 관리 하고 내부적으로 삭제 생성이 일어난다(+ 가비지컬렉션).

총 정리하자면 스냅숏 격리를 사용할 때 데이터를 읽을 수 있는 조건은

- 읽기 대상 객체를 쓴 커밋이 완료됐을 때
- 읽기 대상 객체가 삭제되지 않았을 때, 혹은 삭제 됐지만 삭제요청이 커밋되지 않았을 때.

Mysql에선 스냅숏격리를 반복읽기 라고 부른다.

---

### 갱신 손실 방지

두 트랜잭션이 동시에 객체를 수정할 때 앞의 갱신이 손실된다.

- 원시적 쓰기 연산

> update table set value = value + 1 where id = 1;

갱신 손실로부터 안전한 update 쿼리이다.

- 명시적 잠금

SELECT - FOR UPDATE 사용

- 갱신 손실 자동 감지

자동으로 감지하고 트랜잭션을 어보트 시키는 기능
Mysql에는 이 기능이 없다.

- Compare-and-set 연산

단일 객체 트랜잭션에서 사용하는 방법이다.
현재 읽은 값이 이전 읽은 값과 일치하지 않으면 반영되지 않고 재시도한다.
ex)

> update T set value = 'new' where id = 1 AND value = 'old';

- 충돌 해소와 복제

많은 복제 데이터베이스에서 기본설정인 LWW(최송쓰기승리)는 갱신 손실이 발생하기 쉽다.
원자적 연산의 방법은 복제상황에서도 잘 동작시킬 수 있는 방법이다. (리악 예시)

---

### 쓰기 스큐와 팬턴

**쓰기 스큐**

회의실 예약을 예시로 들자
회의실이 비어있는지 select 하고 insert 하는 트랜잭션이 있다고 한다.
두 트랜잭션이 동시에 시작됐다.
스냅숏 격리를 사용중인 경우엔 두 트랜잭션의서의 select 모두 같은 상태의 스냅숏을 읽었기 때문에 회의실이 중복 insert 될 수 있다.

이를 방지하기 위한 방법은 직렬성을 보장하는 것이다.

혹은 SELECT FOR UPDATE를 사용하는 명시적 잠금도 가능한데, 이는 잠금을 얻을 row가 이미 존재해야지만 가능한 대처방법이다. 이처럼 어떤 트랜잭션에서의 쓰기가 다른 읽기 질의 결과를 바꾸는 효과를 **팬텀**이라 한다.

select for update를 사용하기 위해 인위적으로 row를 미리 생성해두는 **충돌 구체화** 방법이 있지만, 어렵고 오류가 발생하기 쉬워서 직렬성 격리 수준이 더 선호된다.

---

### 직렬성

가장 강력한 격리수준

- 2PL (2단계 잠금)

쓰기 트랜잭션은 다른 쓰기뿐 아닌 읽기도 막는다.
잠금을 많이 사용하므로 데드락이 많이 발생할 수 있다.
성능이 안좋다

- 색인을 이용한 범위 잠금

색인이 있는 값의 범위에 공유잠금 걸기.
(적절한 색인이 없다면 테이블 전체에 공유잠금)

공유 잠금(데이터의 변경을 금지한다)
독점 잠금(읽기 까지 금지한다)

- 직렬성 스냅숏 격리(SSI)
