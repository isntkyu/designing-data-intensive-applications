# 일관성과 합의

대부분의 복제 데이터베이스는 최종적일관성을 제공한다.  
하지만 이것은 매우 약한 보장이다. 언제 복제본이 수렴될지에 대해서 이야기하지 않는다.

데이터베이스는 표면적으로 읽고 쓰는 변수처럼 사용하지만 사실 훨씬 복잡하기 때문이다.  
(애플리케이션은 예전값이 읽히거나 읽기가 실패하는 것을 예상하고 동작하지 않는다.)

이번 장에서는 더욱 강한 일관성 모델을 살펴본다.  
물론 일관성이 강하다면 성능문제나 약한 내결함성을 가질 수 있다.

트랜잭션 격리수준 계층과 비슷한 점이 있다.  
하지만, 트랜잭션 격리는 동시에 실행되는 트랜잭션 때문에 발생하는 경쟁 조건을 회피하기 위한 것이지만,  
분산 일관성은 지연과 결함이 있더라도 복제본의 상태를 코디네이션 하는데에 목적이 있다.

- 공통적으로 사용되는 가장 강한 일관성 모델 `선형성`
- 이벤트 순서화 문제, 특히 인과성과 전체 순서화
- 분산 트랜잭션의 원자적 커밋. 합의 문제의 해결책

---

## 선형성

데이터 복제본이 하나라는 환상을 만든다.  
원자적 일관성, 강한 일관성, 즉각 일관성, 외부 일관성

== 최신성 보장

한 클라이언트의 읽기가 1을 반환한다면, 새로운 쓰기연산이 진행중이더라도  
다른 클라이언트도 1을 조회해야한다.

모든 요청과 응답 시점을 기록하고, 유효한 순서대로 배열되어야함.

!= 트랜잭션 격리 직렬성(어떤 순서에 따라 실행되는 것처럼 동작)  
선형성은 트랜잭션으로 묶지 않아서 쓰기 스큐를 막지 못한다.

2단계 잠금, 엄격한 직렬성이나 실제적인 직렬실행 구현은 선형적이다

그러나 스냅숏 격리는 선형적이지 않다.

---

- 단일 리더 복제의 리더는 잠금획득이 성공한 노드. 이 잠금은 선형적이어야 한다.

- 유일성 제약 조건은 선형성이 필요하다.

- 파일 저장소와 메시지 큐 두 채널이 있는 경우 선형성의 최신성 보장이 중요 (image resizing 예시)

---

### 선형성 시스템 구현하기

가장 쉬운 방법은 데이터 복사본을 하나 사용하기.

- 단일 리더 복제
  - 선형적이 될 가능성이 있음
  - 스냅숏 격리를 사용하지 않아야함.
  - 노드가 본인이 리더라고 착각하는 경우에서 위반.
  - 비동기 복제의 장애복구시 커밋된 쓰기가 손실되는 경우 위반.
- 합의 알고리즘
  - 선형적이다.
  - ex, 아파치 주키퍼
- 다중 리더 복제
  - 비선형적이다.
- 리더 없는 리더복제
  - 아마도 비선형적
  - 다이나모 스타일
  - 최종 쓰기 승리 방법은 비선형적이다.
  - 느슨한 정족수는 비선형적이고, 엄격한 정족수도 비선형 가능성이 있다.

\*정족수

---

### 선형성 비용

가용성과의 트레이드오프 (CAP)

---

### 순서화 보장

선형성: 전체 순서  
인과성: 부분 순서

선형성은 강력하지만 성능과 가용성이 안좋다.  
인과적 일관성만으로 절충이 가능하며 가냥 가용성 높은 일관성 모델이며, 진짜 필요한 것이다

> 인과성을 가져가면서 설계하는 실력으로써 성능 손해없이 가용성 높은 일관성을 구현할 수 있다는 것인듯

일련번호와 타임스탬프, 논리적 시계를 통한 순서화로 인과성을 부과할 수 있다.

단일리더복제 에서는 복제로그의 일련번호로 인과성을 잡아줄 수 있다.

- 램포트 타임스탬프  
  일련번호 부과 아이디어

- 전체 순서 브로드캐스트(원자적 브로드캐스트)  
  전체 순서가 언제 확정되는지 알아야한다.  
  increment-and-get / compare-and-set 연산으로 구현

---

### 분산 트랜잭션과 합의

원자적 커밋: 모든 노드가 트랜잭션 결과에 동의
합의 불가능성: 현실에서는 노드가 죽을 수 있다고 가정해야해서 완전 신뢰성있는 합의는 불가하다.

#### 2단계 커밋 알고리즘 (2PC)

- 원자적 커밋을 제공한다.
- 코디네이터(트랜잭션 관리자)를 사용한다.
- 준비요청 이라는 단계가 있다.
- 모든 노드에서 동의하면 커밋하고 하나라도 거부하면 모든 노드에 어보트요청을 하는 알고리즘
- '네'라고 대답한 노드는 취소할 수 없다. 언제든 커밋될 수 있음.
- 네트워크에러가 발생하면 코디네이터가 트랜잭션을 어보트 하는데 무한히 시도한다.
- 참여자는 코디네이터의 명령을 기다린다.(의심스러운 상태 in doubt)
- 코디네이터 복구를 기다려야 하기 때문에 블로킹 원자적 커밋( <-> 논블로킹 원자적 커밋: 3단계 커밋 알고리즘, 노드가 죽었는지 판별할 신뢰도있는 알고리즘 필요함)

#### 현실의 분산 트랜잭션

- 매우 무거운 성능 손해

#### XA 트랜잭션

- 거의 모든 RDB와 여러 메시지 브로커에서 지원

