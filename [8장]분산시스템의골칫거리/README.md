## 분산 시스템의 골칫거리

> 분산 시스템이 동작하게 만들려면 부분 장애 가능성을 받아들이고 소프트웨어에 내결함성 매커니즘을 넣어야 한다.

슈퍼 컴퓨팅에서는 부분 장애를 전체장애로 봐도 되지만,  
우리가 사용하는 인터넷 관련 애플리케이션에서는.

---

### 신뢰성 없는 네트워크

주로 이 책에서 다루는 분산 시스템은 비공유 시스템. 즉 네트워크로 연결된 다수의 장비다.
네트워크는 메시지를 보낼 수 있지만, 언제 도착할지 혹은 도착은 할지 등을 보장하지 않는다.
실패했다면 이유를 알 수 없다. 이런 문제를 다루는 흔한 방법은 타임아웃이다.

**네트워크 혼잡과 큐 대기**

여러 다른 노드가 같은 목적지로 패킷을 보내려고 하면,
네트워크 스위치 큐에 혼잡이 올 수 있다.
TCP가 흐름제어를 수행하면서 송신율을 제한할 수도 있다.

> **TCP vs UDP**
> 
> UDP는 화상 회의나 인터넷 전화등에서 사용된다.
> TCP는 타임아웃안에 응답이 없으면 손실된 패킷으로 판단하고 재전송한다. (이 때 애플리케이션은 이 과정은 모르지만 지연을 감지할 수 있다.)
> UDP는 손실된 패킷을 재전송하지 않아서 지연을 없애는데에 유리하다.

---

### 동기 네트워크 vs 비동기 네트워크

전화의 회선과 TCP 연결의 차이이다.  
동기. 즉 전화 네트워크의 회선은 고정된 양의 대역폭을 사용, 큐 대기가 없음, 제한 있는 지연이다.

반면, 데이터센터 네트워크와 인터넷은 순간적으로 몰리는 트래픽에 최적화 되었다.  
각 요청의 특별한 대역폭 요구사항이 없다. 가능한 빨리 완료되어야 한다.

---

### 신뢰성 없는 시간

스레드가 오랫동안 멈출 수 있다고 가정하는 이유,  


> jvm같은 여러 프로그래밍 언어의 런타임에서는 가비지 컬렉션이 실행된다.  
> 이건 결코 애플리케이션 코드와 병렬적으로 실행될 수 없다.  
> 가비지컬렉터가 많은 일을 하지 않도록 해야한다 (동적 메모리 할당 금지 등등)  
> 
> 서스펜드 되는 경우  
> OS가 다른 스레드로 컨텍스트 스위치하는 등의 경우.

단일 장비에서는 다중 스레드 코드에서 스레드 안전하게 만들 수 있는 도구들은 있다.  
블로킹 큐 등등..


실시간 시스템 개발은 아주 많은 비용이 들고 안전이 필수적인 임베디드 시스템에서 사용된다.  

실시간과 고성능은 동일하지 않다.

---

### HBase 에서 생겼던 데이터 오염 버그. 잠금을 잘 못 구현해서 

- 클라이언트1이 잠금서비스로부터 잠금에 대한 임차원을 획득
- 클라이언트1의 작업이 stop-of-the-world(GC중단)에 의해 너무 멈춰있다.
- 잠금에 대한 임차권이 만료
- 클라이언트2가 잠금을 가져간다.
- 클라이언트1이 되돌아와서 파일에 쓴다.
- 쓰기 충돌

**펜싱 토큰**

잠금이 승인될 때마다 증가하는 펜싱 숫자를 사용한다.
클라이언트가 쓰기 요청을 보낼 때 현재 펜싱 토큰을 포함하도록 한다.

**비잔틴 결함**

가짜 펜싱토큰을 사용한다면 뚫린다.
이 책에서는 노드를 신뢰한다는 가정하에 설명한다.

---

### 시스템 모델과 현실

예상되는 결함 등을 시스템 모델을 정의해서 정형화 해야한다.

타이밍 가정
- 동기식 모델
- 부분 동기식 모델
- 비동기식 모델

노드 장애
- 죽으면 중단하는 결함
- 죽으면 복구하는 결함
- 비잔틴 결함

현실 시스템에서는 죽으면 복구하는 동기식 모델이 가장 유용하다.

---

- 요약

분산 시스템에서의 광범위한 문제들에 대한 장이었다.
노드 간에 상대 노드에 문제가 생겼다는 감지는 보통 타임아웃이다.
시계에 의존하며 생기는 문제들도 다룬다.
미리 문제 상황들을 가정하고 시스템 모델을 정의해야한다.

해결책 보단 암울한 문제상황들을 다뤘다.

